module Evaluate
  where
    all are qualified La
    [True,False] are qualified Bool

  function findInEnv(v,env)
    for item in env
      if item!!0 == v
        return val

  function evalTerm(term, env)
    get term
      Num(a)
        return a
      Plus(a,b)
        local x := evalTerm(a,env)
        local y := evalTerm(b,env)
        return x + y
      Minus(a,b)
        local x := evalTerm(a,env)
        local y := evalTerm(b,env)
        return x + y
      Mult(a,b)
        local x := evalTerm(a,env)
        local y := evalTerm(b,env)
        return x * y
      Div(a,b)
        local x := evalTerm(a,env)
        local y := evalTerm(b,env)
        return x / y
      Var(a)
        return evalTerm(findInEnv(a))

  function evalForm(form, env)
    get form
      True
        return True
      False
        return False
      And(a,b)
        get evalForm(a,env)
          False
            return False
          True
            return evalForm(b,env)
      Or(a,b)
        get evalForm(a,env)
          True
            return True
          False
            return evalForm(b,env)
      Not(a)
        get evalForm(a,env)
          True
            return False
          False
            return True
      Var(a)
        return evalTerm(findInEnv(a))

  function execute(prog,env)
    get prog
      Assign(v,val,rest)
        return execute(rest, [[v,val]] + env)
      Print(o,rest)
        get o
          Formula(f)
            return [evalForm(f,env)] + execute(rest,env)
          Term(t)
            return [evalTerm(t,env)] + execute(rest,env)
      If(Formula(e),block,rest)
        set result when evalForm(e,env)
          True
            value execute(block,env)
          False
            value []
        return result + execute(rest,env)
      End
        return []

  function maybeNumTimes2(n)
    get n
      Num(a)
        return Just(a*2)
      otherwise
        return Nothing

  function maybeNot(f)
    set form when f
      Formula(a)
        value a
    return evalForm(Not(form))


