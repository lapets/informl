module Evaluate
  where
    all are qualified Test

  function evalTerm(term, env)
    get term
      Num(a)
        return a
      Plus(a,b)
        local x = evalTerm(a,env)
        local y = evalTerm(b,env)
        return x + y
      Minus(a,b)
        local x = evalTerm(a,env)
        local y = evalTerm(b,env)
        return x - y
      Mult(a,b)
        local x = evalTerm(a,env)
        local y = evalTerm(b,env)
        return x * y
      Div(a,b)
        local x = evalTerm(a,env)
        local y = evalTerm(b,env)
        return x / y
      Var(a)
        get env[a]
          Term(t)
            return evalTerm(t,env)

  function evalForm(form, env)
    get form
      True
        return True
      False
        return False
      And(a,b)
        get evalForm(a,env)
          False
            return False
          True
            return evalForm(b,env)
      Or(a,b)
        get evalForm(a,env)
          True
            return True
          False
            return evalForm(b,env)
      Not(a)
        get evalForm(a,env)
          True
            return False
          False
            return True
      Var(a)
        get env[a]
          Formula(f)
            return evalForm(f,env)

  function evalStatement(stmt,env)
    get stmt
      Assign(v,val)
        get v
          Var(a)
            env[a] = val
            return null 
      Print(o)
        get o
          Formula(f)
            return evalForm(f,env)
          Term(t)
            return evalTerm(t,env)
      If(Formula(e),block)
        get evalForm(e,env)
          True
            return evalStatement(block,env)
          False
            return null

  function execute(prog)
    local env = {}
    get prog
      Program(ss)
        local out = (\x -> evalStatement(x,env)) maps ss
        local ret = []
        for o in out
          if o != null
            ret += o
        return ret



